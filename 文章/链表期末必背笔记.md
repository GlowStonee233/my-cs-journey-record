# 链表的本质

> **链表不是一个变量，而是一堆结构体通过 next 保存地址值连起来**

- `head`：只是一个**指针变量**  
- 链表的“头”= `head` 里存的那个地址  
- 插入 / 删除 ≠ 改结构  
  👉 **本质是修改指针里存的地址值**

---

# 结构体定义（标准）

```c
typedef struct Node {
    int data;
    struct Node *next;
} Node;
```

---

# 创建节点（malloc 必考）

## ✅ 正确代码（模板）

```c
Node *p = (Node*)malloc(sizeof(Node));
p->data = 10;
p->next = NULL;
```

## ❌ 易错点

```c
malloc(sizeof(Node*))   // ❌ 只分配了指针大小
```

---

# 创建链表（必考大题）

## 一、核心原则（先背）

> **创建链表第一句：`Node *head = NULL;`**

---

## 二、尾插法创建链表（最常考）

```c
Node *head = NULL;
int x;
while(scanf("%d", &x) && x != -1){
    Node *p = (Node*)malloc(sizeof(Node));
    p->data = x;
    p->next = NULL;

    if(head == NULL){
        head = p;
    } else {
        Node *q = head;
        while(q->next != NULL){
            q = q->next;
        }
        q->next = p;
    }
}
```

---

## 三、头插法创建链表

```c
Node *head = NULL;
int x;
while(scanf("%d", &x) && x != -1){
    Node *p = (Node*)malloc(sizeof(Node));
    p->data = x;

    p->next = head;
    head = p;
}
```

📌 顺序会反过来

---

# 头插法（送分题）

```c
p->next = head;
head = p;
```

口诀：**先接旧头，再换新头**

---

# 尾插法（高频易错）

```c
if(head == NULL){
    head = p;
    p->next = NULL;
}
else{
    Node *q = head;
    while(q->next != NULL){
        q = q->next;
    }
    q->next = p;
    p->next = NULL;
}
```

---

# 中间插入节点（拉开差距的重点）

## 核心结论（必背）

> **中间插入 = 找前驱节点 prev**  
> **顺序永远是：先连新节点，再断原链**

```c
p->next = prev->next;
prev->next = p;
```

---

## 一、按位置插入（在第 i 个位置前）

```c
Node *insertByPos(Node *head, int i, int x){
    Node *p = (Node*)malloc(sizeof(Node));
    p->data = x;
    p->next = NULL;

    if(i == 1){              // 头插
        p->next = head;
        return p;
    }

    Node *q = head;
    int k = 1;
    while(q != NULL && k < i-1){
        q = q->next;
        k++;
    }

    if(q == NULL){           // 位置非法
        free(p);
        return head;
    }

    p->next = q->next;       // 中间插入
    q->next = p;

    return head;
}
```

---

## 二、按值插入（在第一个 data == x 的节点后）

```c
Node *insertAfterValue(Node *head, int x, int val){
    Node *q = head;
    while(q != NULL){
        if(q->data == x){
            Node *p = (Node*)malloc(sizeof(Node));
            p->data = val;

            p->next = q->next;
            q->next = p;
            break;
        }
        q = q->next;
    }
    return head;
}
```

---

# 遍历链表（基础）

```c
Node *p = head;
while(p != NULL){
    printf("%d ", p->data);
    p = p->next;
}
```

---

# 删除节点（期末压轴）

## 删除第一个 data == x 的节点

```c
Node *p = head;
Node *prev = NULL;

while(p != NULL){
    if(p->data == x){
        if(prev == NULL){        // 删除头结点
            head = p->next;
        } else {                 // 删除中间或尾结点
            prev->next = p->next;
        }
        free(p);
        break;
    }
    prev = p;
    p = p->next;
}
```

📌 **先断链，再 free**

---

# 释放整个链表

```c
Node *p = head;
while(p != NULL){
    Node *temp = p;
    p = p->next;
    free(temp);
}
head = NULL;
```

---

# 期末必背 10 句话

1. 链表 = 节点 + next 中的地址值
2. head 只是入口指针，不是节点
3. malloc 用 sizeof(Node)
4. 创建链表第一句：head = NULL
5. 头插法：先接旧头，再换新头
6. 尾插法：找 q->next == NULL
7. 中间插入：先连新，再断旧
8. 遍历条件：p != NULL
9. 删除节点：先改指针，再 free
10. free 不会修改任何指针

